#!/usr/bin/env python3

import os, sys
import numpy as np
import math
from scipy.spatial import cKDTree
import gen, g_var, f_loc, at_mod


def build_atomistic_system(cg_residues,residue_type, box_vec):
    system={}
    atomistic_fragments={}
#### for each residue type covert to atomistic except protein
    # for residue_type in [key for value, key in enumerate(cg_residues) if key not in ['PROTEIN']]:
    if residue_type not in system and residue_type != 'ION':
        system[residue_type] = 0
#### reset counters for each residue type
    print('Converting residue type: ' +residue_type)
#### creates folder for residue type
    gen.mkdir_directory(g_var.working_dir+residue_type)

    if residue_type in ['ION','SOL']:
        atomistic_fragments[residue_type] = atomistic_non_protein_solvent(residue_type, cg_residues[residue_type])
        if residue_type in ['ION']:
            system, atomistic_fragments = solvent_ion(box_vec, system, atomistic_fragments, residue_type)
        else:
            system, atomistic_fragments = solvent_sol(box_vec, system, atomistic_fragments, residue_type)   
    else:
        atomistic_fragments[residue_type] = atomistic_non_protein_non_solvent(residue_type, cg_residues[residue_type])
        system, atomistic_fragments = non_solvent( box_vec, system, atomistic_fragments, residue_type)

    return system 

def non_solvent(box_vec, system, atomistic_fragments, residue_type):
#### loop through all resids of that residue type 
    for resid in atomistic_fragments[residue_type]:
        pdb_output = gen.create_pdb(g_var.working_dir+residue_type+'/'+residue_type+'_'+str(resid)+'.pdb', box_vec)         
        atomistic_fragments[residue_type][resid] = check_hydrogens(atomistic_fragments[residue_type][resid])
    ####### check if any atoms in residue overlap #######
        coord=[]
        for atom in atomistic_fragments[residue_type][resid]:
            coord.append(atomistic_fragments[residue_type][resid][atom]['coord'])
        coord=at_mod.check_atom_overlap(coord)
        for atom_val, atom in enumerate(atomistic_fragments[residue_type][resid]):
            atomistic_fragments[residue_type][resid][atom]['coord']=coord[atom_val]

        for at_id, atom in enumerate(atomistic_fragments[residue_type][resid]):
        #### write residue out to a pdb file
            short_line=atomistic_fragments[residue_type][resid][at_id+1]
            pdb_output.write(g_var.pdbline%((at_id+1,short_line['atom'],short_line['res_type'],' ',1,short_line['coord'][0],
                             short_line['coord'][1],short_line['coord'][2],short_line['extra'],short_line['connect']))+'\n')
    system[residue_type]=int(resid)+1
    return system, atomistic_fragments

def solvent_sol(box_vec, system, atomistic_fragments, residue_type):
    #### creates solvent directory and SOL key in system dictionay otherwise it appends solvent molecules to sol pdb
    if not os.path.exists(g_var.working_dir+'SOL'+'/SOL_0.pdb'):   
        # system['SOL']=0
        pdb_sol = open(g_var.working_dir+'SOL'+'/SOL_0.pdb', 'w')
        pdb_sol.write('REMARK    GENERATED BY sys_setup_script\nTITLE     SELF-ASSEMBLY-MAYBE\nREMARK    Good luck\n'
                      +box_vec+'MODEL        1\n')
    else:
        pdb_sol = open(g_var.working_dir+'SOL'+'/SOL_0.pdb', 'a')
    for resid in atomistic_fragments[residue_type]:
    ####### check if any atoms in residue overlap #######
        coord=[]
        for atom in atomistic_fragments[residue_type][resid]:
            coord.append(atomistic_fragments[residue_type][resid][atom]['coord'])
        coord=at_mod.check_atom_overlap(coord)
        for atom_val, atom in enumerate(atomistic_fragments[residue_type][resid]):
            atomistic_fragments[residue_type][resid][atom]['coord']=coord[atom_val]

        for at_id, atom in enumerate(atomistic_fragments[residue_type][resid]):
        #### separates out the water molecules from the ion in the fragment
            if atomistic_fragments[residue_type][resid][at_id+1]['frag_mass'] > 1:                  
                system['SOL']+=1
            short_line=atomistic_fragments[residue_type][resid][at_id+1]
            pdb_sol.write(g_var.pdbline%((at_id+1,short_line['atom'],short_line['res_type'],' ',1,short_line['coord'][0],
                          short_line['coord'][1],short_line['coord'][2],short_line['extra'],short_line['connect']))+'\n')

    return system, atomistic_fragments

def solvent_ion(box_vec, system, atomistic_fragments, residue_type):
    #### creates ion pdb with header
    gen.mkdir_directory(g_var.working_dir+'ION/min')
    pdb_ion = gen.create_pdb(g_var.working_dir+residue_type+'/'+residue_type+'_merged.pdb', box_vec)
    for resid in atomistic_fragments[residue_type]:
        for at_id, atom in enumerate(atomistic_fragments[residue_type][resid]):
        #### write ion coordinate out
            short_line=atomistic_fragments[residue_type][resid][at_id+1]
            pdb_ion.write(g_var.pdbline%((at_id+1,short_line['atom'],short_line['res_type'],' ',1,short_line['coord'][0],
                          short_line['coord'][1],short_line['coord'][2],short_line['extra'],short_line['connect']))+'\n')
            if atomistic_fragments[residue_type][resid][at_id+1]['res_type'] != 'SOL':
                if atomistic_fragments[residue_type][resid][at_id+1]['res_type'] not in system:
                    system[atomistic_fragments[residue_type][resid][at_id+1]['res_type']]=1
                else:
                    system[atomistic_fragments[residue_type][resid][at_id+1]['res_type']]+=1
    return system, atomistic_fragments

def atomistic_non_protein_non_solvent(cg_residue_type,cg_residues):
    atomistic_fragments={}  #### residue dictionary
#### run through every residue in a particular residue type
    residue_type={}
    residue_type_mass={}
    for cg_resid, cg_residue in enumerate(cg_residues):
        atomistic_fragments[cg_resid]={}
        frag_location=at_mod.fragment_location(cg_residue_type) ### get fragment location from database
        residue_type[cg_residue_type], residue_type_mass[cg_residue_type] = at_mod.get_atomistic(frag_location)
        for group in residue_type[cg_residue_type]:
            # print(residue_type[cg_residue_type][group], '\n')
            center, at_frag_centers, cg_frag_centers, group_fit = at_mod.rigid_fit(residue_type[cg_residue_type][group], residue_type_mass[cg_residue_type], cg_residue, cg_residues[cg_residue])
            at_connect, cg_connect = at_mod.connectivity(cg_residues[cg_residue], at_frag_centers, cg_frag_centers, group_fit, group)

            if len(at_connect) == len(cg_connect):
                xyz_rot_apply=at_mod.rotate(np.array(at_connect)-center, np.array(cg_connect)-center, False)
            else:
                print('atom connections: '+str(len(at_connections))+' does not equal CG connections: '+str(len(cg_connections)))
                sys.exit('residue number: '+str(residue_number)+', residue type: '+str(resname)+', group: '+group)
            for bead in group_fit:
                for atom in group_fit[bead]:
                    group_fit[bead][atom]['coord'] = at_mod.rotate_atom(group_fit[bead][atom]['coord'], center, xyz_rot_apply)   
                    atom_new = group_fit[bead][atom].copy()
                    atomistic_fragments[cg_resid][atom] = atom_new
    return atomistic_fragments   

def atomistic_non_protein_solvent(cg_residue_type,cg_residues): 
    atomistic_fragments={}  #### residue dictionary
#### run through every residue in a particular residue type
    residue_type={}
    residue_type_mass={}
    for cg_resid, cg_residue in enumerate(cg_residues):
        for bead in cg_residues[cg_residue]:
            fragment = bead
            break
        atomistic_fragments[cg_resid]={}
        frag_location=at_mod.fragment_location(cg_residue_type) ### get fragment location from database
        residue_type[cg_residue_type], residue_type_mass[cg_residue_type] = at_mod.get_atomistic(frag_location)
        for res_type in residue_type[cg_residue_type]:
            if fragment in residue_type[cg_residue_type][res_type]:
                center, at_frag_centers, cg_frag_centers, group_fit = at_mod.rigid_fit(residue_type[cg_residue_type][res_type], residue_type_mass[cg_residue_type]
                                                                                       , cg_residue, cg_residues[cg_residue])
                xyz_rot_apply=[np.random.uniform(0, math.pi*2), np.random.uniform(0, math.pi*2), np.random.uniform(0, math.pi*2)]
                for bead in group_fit:
                    for atom in group_fit[bead]:
                        group_fit[bead][atom]['coord'] = at_mod.rotate_atom(group_fit[bead][atom]['coord'], center, xyz_rot_apply)   
                        atom_new = group_fit[bead][atom].copy()
                        atomistic_fragments[cg_resid][atom] = atom_new
    return atomistic_fragments

def check_hydrogens(residue):
#### finds the connecting carbons and their associated carbons [carbon atom, hydrogen ref number, connecting ref number]    
    # connect=[]
    connect=[]
    con_coord = []
    h_atom = []
    for atom_num, atom in enumerate(residue):
        resname=residue[atom]['res_type']
        for bead in f_loc.sorted_connect[resname]:
            if residue[atom]['atom'] in f_loc.sorted_connect[residue[atom]['res_type']][bead]:
                connect.append(atom)
                con_coord.append(residue[atom]['coord'])
        if residue[atom]['atom'] in f_loc.hydrogen[residue[atom]['res_type']]:
            h_atom.append(atom)    
    for atom in h_atom:
        connected_atom = residue[atom]['coord']
        dist=np.sqrt(((np.array(con_coord)[:,0] - np.array(residue[atom]['coord'])[0])**2)+((np.array(con_coord)[:,1] - np.array(residue[atom]['coord'])[1])**2)+((np.array(con_coord)[:,2] - np.array(residue[atom]['coord'])[2])**2))
        connecting_atom = residue[connect[np.argmin(dist)]]['coord']
        hc = []
        hc_at_index = []
        for atom_num, res_atom in enumerate(residue):
            if residue[res_atom]['atom'] in f_loc.hydrogen[resname][residue[atom]['atom']]:
                hc.append(residue[res_atom]['coord'])
                hc_at_index.append(res_atom)
        h_com=np.mean(np.array(hc), axis=0)             

    # #### vector between H COM and bonded carbon 
        vector=np.array([h_com[0]-connected_atom[0],h_com[1]-connected_atom[1],h_com[2]-connected_atom[2]])
    # #### flips  
        h_com_f=h_com+vector*2
        d1 = np.sqrt((h_com[0]-connecting_atom[0])**2+(h_com[1]-connecting_atom[1])**2+(h_com[2]-connecting_atom[2])**2)
        d2 = np.sqrt((h_com_f[0]-connecting_atom[0])**2+(h_com_f[1]-connecting_atom[1])**2+(h_com_f[2]-connecting_atom[2])**2)
        if d2 > d1:
            for h_at in hc_at_index:
                residue[h_at]['coord']=residue[h_at]['coord']+vector*2
    return residue

def merge_minimised(residue_type, np_system, box_vec):
    os.chdir(g_var.working_dir+residue_type+'/min')
    print('Merging individual residues : '+residue_type)
#### create merged pdb in min folder
    pdb_output=gen.create_pdb(g_var.working_dir+residue_type+'/min/'+residue_type+'_merged.pdb', box_vec)  
    if residue_type =='SOL':
        resid_range=1
    else:
        resid_range=np_system[residue_type]
    merge,merge_coords=[],[]
#### run through every resid 
    for resid in range(resid_range):
        merge_temp ,dump = at_mod.read_in_merged_pdbs([], [], g_var.working_dir+residue_type+'/min/'+residue_type+'_'+str(resid)+'.pdb')
        merge, merge_coords = at_mod.fix_chirality(merge,merge_temp,merge_coords)    
    if residue_type !='SOL':
        merge_coords = at_mod.check_atom_overlap(merge_coords)
    for line_val, line in enumerate(merge):
        pdb_output.write(g_var.pdbline%((int(line['atom_number']), line['atom_name'], line['residue_name'],' ',line['residue_id'],\
            merge_coords[line_val][0],merge_coords[line_val][1],merge_coords[line_val][2],1,0))+'\n')
    pdb_output.write('TER\nENDMDL')
    pdb_output.close()

